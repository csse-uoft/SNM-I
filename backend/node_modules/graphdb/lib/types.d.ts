/**
 * Instantiates the user.
 * @param token - is the authentication token obtained with the login.
 * @param password - of the user
 * @param data - is the logged in user data which contains the username
 * the role and settings.
 */
declare class User {
    constructor(token: string, password: string, data: any);
    /**
     * @returns the authentication token.
     */
    getToken(): string;
    /**
     * Removes the token which effectively make the user unauthenticated.
     */
    clearToken(): void;
    /**
     * @returns the logged in username.
     */
    getUsername(): string;
    /**
     * @returns the user's password.
     */
    getPassword(): string;
    /**
     * @returns an array of user roles.
     */
    getAuthorities(): string[];
}

/**
 * Client configuration constructor.
 * @param endpoint - server base URL that will be prepend
 * to all server requests
 */
declare class ClientConfig {
    constructor(endpoint: string);
    /**
     * Sets the default headers map for each HTTP request.
     * @param headers - the default headers
     * @returns the concrete configuration config for method chaining
     */
    setHeaders(headers: {
        [key: string]: string;
    }): this;
    /**
     * Returns the default headers for each HTTP request.
     * @returns the default headers map
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * @returns the username
     */
    getUsername(): string;
    /**
     * @returns the user password
     */
    getPass(): string;
    /**
     * @returns if the user should be re-logged in after token expires
     */
    getKeepAlive(): boolean;
    /**
     * @returns the concrete configuration config for method chaining
     */
    setKeepAlive(keepAlive: boolean): this;
    /**
     * Username and password for user logging setter.
     * Sets basic authentication as client authentication type.
     * @returns the concrete configuration config for method chaining
     */
    useBasicAuthentication(username?: string, pass?: string): this;
    /**
     * @returns [basicAuth] if use Basic Auth
     */
    getBasicAuthentication(): boolean;
    /**
     * @returns [gdbTokenAuth] if use Gdb Token Auth
     */
    getGdbTokenAuthentication(): boolean;
    /**
     * Username and password for user logging setter.
     * Sets gdb token authentication as client authentication type.
     * *
     * @returns the concrete configuration config for method chaining
     */
    useGdbTokenAuthentication(username?: string, pass?: string): this;
    /**
     * Disables authentication.
     */
    disableAuthentication(): void;
    /**
     * Sets the server's endpoint URL.
     * @param endpoint - the endpoint URL
     * @returns the current config for method chaining
     */
    setEndpoint(endpoint: string): this;
    /**
     * Returns the server's endpoint URL.
     * @returns the endpoint URL
     */
    getEndpoint(): string;
    /**
     * Returns <code>true</code> if basic or gdb token authentication
     * is enabled. <code>false</code> otherwise.
     * @returns is authentication enabled
     */
    shouldAuthenticate(): boolean;
}

/**
 * Instantiates new HTTP client with the supplied base URL and default
 * request timeouts.
 * @param baseURL - base URL that will be prepend to all requests
 * GET
 */
declare class HttpClient {
    constructor(baseURL: string);
    /**
     * Sets the provided header map as default for all requests.
     *
     * Any additional headers provided in the request configuration will
     * be merged with this default map.
     * @param headers - map with default headers
     * @returns the current client for method chaining
     */
    setDefaultHeaders(headers: Map<string, string>): HttpClient;
    /**
     * Sets the default request read timeout. It will be used in case requests
     * don't explicitly specify it in their request configurations.
     * @param readTimeout - the default read timeout
     * @returns the current client for method chaining
     */
    setDefaultReadTimeout(readTimeout: number): HttpClient;
    /**
     * Sets the default request write timeout. It will be used in case requests
     * don't explicitly specify it in their request configurations.
     * @param writeTimeout - the default write timeout
     * @returns the current client for method chaining
     */
    setDefaultWriteTimeout(writeTimeout: number): HttpClient;
    /**
     * Performs HTTP request using the supplied request builder.
     * @returns a promise resolving to the request's response
     */
    request(requestBuilder: HttpRequestBuilder): Promise<any>;
    /**
     * Returns the base URL which this http client uses to send requests.
     * @returns the base URL for each request
     */
    getBaseURL(): string;
}

/**
 * Does default initialization of the configuration.
 */
declare class HttpRequestBuilder {
    /**
     * Prepares new builder for HTTP GET request against the provided URL.
     */
    static httpGet(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP POST request against the provided URL.
     */
    static httpPost(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP PUT request against the provided URL.
     */
    static httpPut(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP PATCH request against the provided URL.
     */
    static httpPatch(url: string): HttpRequestBuilder;
    /**
     * Prepares new builder for HTTP DELETE request against the provided URL.
     */
    static httpDelete(url: string): HttpRequestBuilder;
    /**
     * Add a new http header entry. Blank values are skipped.
     * @param header - type
     * @param value - the header value
     */
    addHeader(header: string, value: string): HttpRequestBuilder;
    /**
     * Sets the headers map.
     * @param headers - the headers map
     */
    setHeaders(headers: {
        [key: string]: string;
    }): HttpRequestBuilder;
    /**
     * Returns the headers map.
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * Add a specific header of type <code>Accept</code> with the given value.
     */
    addAcceptHeader(value: string): HttpRequestBuilder;
    /**
     * Add a specific header of type <code>Content-Type</code> with the given
     * value.
     */
    addContentTypeHeader(value: string): HttpRequestBuilder;
    /**
     * Add a custom GraphDB header which holds a user password for base
     * authentication.
     */
    addGraphDBPasswordHeader(value: string): HttpRequestBuilder;
    /**
     * Add an Authorization header which holds an authorization token.
     */
    addAuthorizationHeader(value: string): HttpRequestBuilder;
    /**
     * Set request parameters object.
     */
    setParams(params: any): HttpRequestBuilder;
    /**
     * Add a new request param.
     */
    addParam(param: string, value: any): HttpRequestBuilder;
    /**
     * Returns the request parameters map.
     */
    getParams(): {
        [key: string]: any;
    };
    /**
     * Set timeout configuration.
     * @param timeout - in ms
     */
    setTimeout(timeout: number): HttpRequestBuilder;
    /**
     * Returns the request timeout.
     */
    getTimeout(): number;
    /**
     * Set a responseType config.
     */
    setResponseType(responseType: string): HttpRequestBuilder;
    /**
     * Returns the request's response type.
     */
    getResponseType(): string;
    /**
     * Sets the data to be sent as request payload.
     * @param data - the payload
     */
    setData(data: any): HttpRequestBuilder;
    /**
     * Gets the data to be sent as payload.
     */
    getData(): any;
    /**
     * Sets the URL against which to perform the request.
     */
    setUrl(url: string): HttpRequestBuilder;
    /**
     * Gets the URL.
     */
    getUrl(): string;
    /**
     * Sets the HTTP method.
     */
    setMethod(method: string): HttpRequestBuilder;
    /**
     * Gets the HTTP method.
     */
    getMethod(): string;
    /**
     * Getter for the configuration.
     */
    get(): any;
}

/**
 * Constructs new wrapper with the supplied response and client.
 * @param response - the HTTP response
 * @param httpClient - client that performed the HTTP request
 */
declare class HttpResponse {
    constructor(response: AxiosResponse, httpClient: HttpClient);
    /**
     * Returns the HTTP response's data.
     * @returns the response data
     */
    getData(): string | any;
    /**
     * Returns the HTTP response's headers.
     * @returns the headers map
     */
    getHeaders(): any;
    /**
     * Sets the elapsed time of the request and response.
     * @param elapsedTime - the elapsed time in milliseconds
     */
    setElapsedTime(elapsedTime: number): void;
    /**
     * Returns the elapsed time of the HTTP request execution.
     * @returns the elapsed time in milliseconds
     */
    getElapsedTime(): number;
    /**
     * Returns the base URL to which this request was performed.
     * @returns the base URL
     */
    getBaseURL(): string;
}

/**
 * Media types.
 */
declare const enum MediaType {
    TEXT_PLAIN = "text/plain",
    APPLICATION_JSON = "application/json",
    TEXT_TURTLE = "text/turtle"
}

/**
 * Supported query content types.
 */
declare const enum QueryContentType {
    X_WWW_FORM_URLENCODED = "application/x-www-form-urlencoded",
    SPARQL_UPDATE = "application/sparql-update",
    SPARQL_QUERY = "application/sparql-query"
}

/**
 * Supported RDF mime types.
 */
declare const enum RDFMimeType {
    RDF_XML = "application/rdf+xml",
    N_TRIPLES = "text/plain",
    TURTLE = "text/turtle",
    TURTLE_STAR = "application/x-turtlestar",
    N3 = "text/rdf+n3",
    N_QUADS = "text/x-nquads",
    JSON_LD = "application/ld+json",
    RDF_JSON = "application/rdf+json",
    TRIX = "application/trix",
    TRIG = "application/x-trig",
    TRIG_STAR = "application/x-trigstar",
    BINARY_RDF = "application/x-binary-rdf",
    SPARQL_RESULTS_XML = "application/sparql-results+xml",
    SPARQL_RESULTS_JSON = "application/sparql-results+json",
    SPARQL_STAR_RESULTS_JSON = "application/x-sparqlstar-results+json",
    SPARQL_STAR_RESULTS_TSV = "application/x-sparqlstar-results+tsv",
    BINARY_RDF_RESULTS_TABLE = "application/x-binary-rdf-results-table",
    BOOLEAN_RESULT = "text/boolean"
}

/**
 * Initializes a console logger.
 *
 * Allows to create a child logger by providing the <code>config</code> param.
 * Anything in this configuration will be appended for each log.
 * @param [config] - optional child logger configuration
 */
declare class ConsoleLogger {
    constructor(config?: any);
    /**
     * Logs an info message.
     * @param args - arguments to be relayed for logging
     */
    info(...args: any[]): void;
    /**
     * Logs a warn message.
     * @param args - arguments to be relayed for logging
     */
    warn(...args: any[]): void;
    /**
     * Logs an error message.
     * @param args - arguments to be relayed for logging
     */
    error(...args: any[]): void;
    /**
     * Logs a debug message.
     * @param args - arguments to be relayed for logging
     */
    debug(...args: any[]): void;
    /**
     * Logs a trace message.
     * @param args - arguments to be relayed for logging
     */
    trace(...args: any[]): void;
}

/**
 * Interface defining the API for logging implementations.
 */
declare interface Logger {
}

/**
 * Utilities related to logging.
 */
declare class LoggingUtils {
    /**
     * Creates an object from the provided HTTP response that is suitable for
     * structured logging.
     *
     * Any additional key-value entries from <code>params</code> will be assigned
     * in the created payload object.
     * @param response - the HTTP response.
     * Used to get the execution time and the base URL
     * @param [params] - additional parameters to be appended
     * @returns the constructed payload object for logging
     */
    static getLogPayload(response: HttpResponse, params?: any): any;
}

/**
 * Instantiates a namespace with its prefix.
 * @param prefix - the namespace prefix
 * @param namespace - the namespace as named node
 */
declare class Namespace {
    constructor(prefix: string, namespace: NamedNode);
    /**
     * Returns the namespace prefix.
     * @returns the namespace prefix
     */
    getPrefix(): string;
    /**
     * Returns the namespace.
     * @returns the namespace as named node
     */
    getNamespace(): NamedNode;
}

/**
 * Utility class for converting strings to terms, terms to quads and
 * quads to string according to the {@link https://rdf.js.org} specification.
 */
declare class TermConverter {
    /**
     * Convert the supplied params to a collection of quads.
     *
     * The produced quads size depends on the supplied amount of context.
     * @param subject - the quad's subject
     * @param predicate - the quad's predicate
     * @param object - the quad's object
     * @param [contexts] - the quad's context
     * @returns a collection of quads constructed from the provided params
     */
    public static getQuads(subject: string, predicate: string, object: string, contexts?: string | string[]): Quad[];
    /**
     * Convert the supplied params to a collection of quads.
     *
     * The quads object term will be a literal with a data type or a language.
     *
     * The produced quads size depends on the supplied amount of context.
     * @param subject - the quad's subject
     * @param predicate - the quad's predicate
     * @param object - the quad's object
     * @param [contexts] - the quad's context
     * @param type - the quad's data type
     * @param language - the quad's literal language
     * @returns a collection of quads constructed from the provided params
     */
    public static getLiteralQuads(subject: string, predicate: string, object: string, contexts?: string | string[], type: string, language: string): Quad[];
    /**
     * Serializes the provided collection of quads to Turtle format or Trig in
     * case any of the quads have context.
     * @param quads - the collection of quads to serialize to Turtle
     * @returns a promise that will be resolved to Turtle or Trig
     * text or rejected if the quads cannot be serialized
     */
    public static toString(quads: Quad[]): string;
    /**
     * Converts the provided value to N-Triple encoded value in case it is not
     * already one or a literal value.
     *
     * For example:
     * <ul>
     *   <li><i>http://resource</i> encodes to <i><http://resource></i></li>
     *   <li><i>"Literal title"@en</i> will not be encoded</li>
     *   <li><i><http://resource></i> encodes to the same value</li>
     * </ul>
     *
     * Empty or null values are ignored.
     * @param value - the value for converting
     * @returns the converted value to N-Triple
     */
    public static toNTripleValue(value: string): string;
    /**
     * Converts the provided values to N-Triple encoded values in case they are
     * not already one or literal values.
     *
     * Empty or null values are ignored.
     * @param values - the values for converting
     * @returns the converted value or values to N-Triple
     */
    public static toNTripleValues(values: string | string[]): string | string[];
    /**
     * Decodes from Base64 encoded RDFStar triple.
     * @param encodedTriple - to be decoded from base64 url string
     * @returns decoded RDFStar triple, returns unchanged if the provided
     * triple is not in the expected format
     */
    static fromBase64RdfStarTriple(encodedTriple: string): string;
    /**
     * Encodes RDFStarTriple to Base64 string.
     * @param triple - to be encoded as base64 url string
     * @returns encoded RDFStart triple, returns unchanged if the provided
     * triple is not in the expected format
     */
    static toBase64RdfStarTriple(triple: string): string;
}

/**
 * Data types from the XSD schema.
 */
declare const enum XSD {
    INTEGER = "xsd:integer",
    DECIMAL = "xsd:decimal",
    STRING = "xsd:string",
    BOOLEAN = "xsd:boolean"
}

/**
 * Abstract class defining the API for content type parsers.
 * @param config - is an object containing the parser configuration.
 */
declare class ContentParser {
    constructor(config: any);
    /**
     * @returns config is the passed during the initialization parser
     * config object.
     */
    getConfig(): any;
    /**
     * If implemented by successors, this must return boolean <code>true</code>
     * when the wrapped parser supports stream reading by default or
     * <code>false</code> otherwise.
     * @returns if the parser supports streaming by default
     */
    isStreaming(): boolean;
    /**
     * Implementations should delegate the actual parsing to underlying parser
     * library or to a custom implementation.
     * @param content - which has to be parsed to given format.
     * @param [config] - optional parser configuration.
     * @returns the converted content.
     */
    parse(content: string, config?: any): Term;
    /**
     * @returns the type which underlying parser supports which should be
     * the type under which it was registered in the parser registry.
     */
    getSupportedType(): string;
}

/**
 * Parse jsonld data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class JsonLDParser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
    isStreaming(): void;
}

/**
 * Parse N-Quads data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class NQuadsParser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
}

/**
 * Parse N-Triples data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class NTriplesParser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
}

/**
 * Parse N3 data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class N3Parser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
}

/**
 * Implementation of registry holding {@link ContentParser} instances and
 * providing interface for registration and access.
 * If this registry is not provided with a list with parsers then it is
 * initialized empty. Otherwise provided parsers are validated if they are
 * compatible with the {@link ContentParser} interface and an error is
 * thrown if there are invalid parsers.
 * @param [parsers] - initialized list with valid parser
 * instances.
 */
declare class ParserRegistry {
    constructor(parsers?: ContentParser[]);
    /**
     * Initializes a console logger.
     */
    initLogger(): void;
    /**
     * Register provided {@link ContentParser} under given key as returned by
     * <code>parser.getSupportedType()</code>.
     * If the type of the provided parser is already registered, then this method
     * will override the registered parser with the provided instance.
     * @param parser - implementation wrapper.
     */
    register(parser: ContentParser): void;
    /**
     * Getter for parser of given type.
     * @param type - of the parser for get.
     * @returns if parser of requested type is found or
     * <code>null</code> otherwise.
     */
    get(type: string): ContentParser;
}

/**
 * Parse rdfxml data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class RDFXmlParser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
    isStreaming(): void;
}

/**
 * Parse a sparql tuple query json result and convert it RDFJS-based
 * data structure.
 *
 * A custom parser library is used for the parsing. Also the N3 DataFactory is
 * used for building the data objects instead of the native RDFJS datafactory as
 * there are some minor discrepancies in between them and we already stuck to N3
 * as a default implementation.
 * @param config - is an object containing the parser configuration.
 */
declare class SparqlJsonResultParser {
    constructor(config: any);
    /**
     * This method should be invoked with a text stream and will return also a
     * stream converted to RDFJS objects.
     *
     * Client of the method can subscribe to following events in order to consume
     * the stream:
     * <code>
     * stream.on('variables', (variables) => console.log(variables));
     * stream.on('data', (bindings) => console.log(bindings));
     * stream.on('error', (error) => console.log(error));
     * </code>
     * @param stream - with the text which has to be parsed
     * to given format.
     * @param [config] - optional parser configuration.
     * @returns a stream with the
     * converted content for SELECT queries and a Promise which resolves to
     * boolean value for ASK queries.
     */
    parse(stream: NodeJS.ReadableStream, config?: any): NodeJS.ReadableStream | Promise<boolean>;
    getSupportedType(): void;
    isStreaming(): void;
}

/**
 * Parse a sparql tuple query xml result and convert it RDFJS-based data
 * structure.
 *
 * A custom parser library is used for the parsing. Also the N3 DataFactory is
 * used for building the data objects instead of the native RDFJS datafactory as
 * there are some minor discrepancies in between them and we already stuck to N3
 * as a default implementation.
 * @param config - is an object containing the parser configuration.
 */
declare class SparqlXmlResultParser {
    constructor(config: any);
    /**
     * This method should be invoked with a text stream and will return also a
     * stream converted to RDFJS objects.
     *
     * Client of the method can subscribe to following events in order to consume
     * the stream:
     * <code>
     * stream.on('variables', (variables) => console.log(variables));
     * stream.on('data', (bindings) => console.log(bindings));
     * stream.on('error', (error) => console.log(error));
     * </code>
     * @param stream - with the text which has to be parsed
     * to given format.
     * @param [config] - optional parser configuration.
     * @returns a stream with the
     * converted content for SELECT queries and a Promise which resolves to
     * boolean value for ASK queries.
     */
    parse(stream: NodeJS.ReadableStream, config?: any): NodeJS.ReadableStream | Promise<boolean>;
    getSupportedType(): void;
    isStreaming(): void;
}

/**
 * Parse TriG data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class TriGParser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
}

/**
 * Parse turtle data to triple/quads
 * @param config - is an object containing the parser configuration.
 */
declare class TurtleParser {
    constructor(config: any);
    parse(): void;
    getSupportedType(): void;
}

/**
 * Does basic initialization.
 */
declare class GetQueryPayload {
    /**
     * @param query - The query as string to be evaluated.
     */
    setQuery(query: string): UpdateQueryPayload;
    /**
     * @returns a query which was populated in the payload.
     */
    getQuery(): string;
    /**
     * @param [queryLn] - the query language that is used for the query.
     */
    setQueryLn(queryLn?: string): GetQueryPayload;
    /**
     * Populates an optional $key:value binding in the payload. Existing bindings
     * will be overridden.
     * @param [binding] - A variable binding name which may appear in the
     *                 query and can be bound to a specific value provided outside
     *                 of the actual query.
     * @param [value] - A variable's binding value. See the binding comment
     */
    addBinding(binding?: string, value?: string): GetQueryPayload;
    /**
     * @param [distinct] - Specifies if only distinct query solutions
     *                  should be returned.
     */
    setDistinct(distinct?: boolean): GetQueryPayload;
    /**
     * @param limit - specifies the maximum number of query solutions to
     *                 return.
     */
    setLimit(limit: number): GetQueryPayload;
    /**
     * @param [offset] - Specifies the number of query solutions to skip.
     */
    setOffset(offset?: number): GetQueryPayload;
    validateParams(): void;
    /**
     * A mandatory parameter which is used for resolving the Accept http header
     * required by the RDF store.
     */
    setResponseType(responseType: string): GetQueryPayload;
    /**
     * @returns response type which was populated in this payload.
     */
    getResponseType(): string;
    /**
     * A mandatory parameter used for resolving request headers and resolving
     * the response parsers.
     */
    setQueryType(queryType: QueryType): GetQueryPayload;
    /**
     * @returns query type which was populated in this payload. The value
     * is one of the {@link QueryType} enum values.
     */
    getQueryType(): string;
    getSupportedContentTypes(): void;
}

/**
 * Supported query languages.
 */
declare const enum QueryLanguage {
    SPARQL = "sparql",
    SERQL = "serql"
}

/**
 * Does basic initialization.
 */
declare class QueryPayload {
    /**
     * @param [inference] - Specifies whether inferred statements should
     *                  be included in the query evaluation.
     */
    setInference(inference?: boolean): QueryPayload;
    /**
     * @param [timeout] - Specifies a maximum query execution time, in
     *                 whole seconds.
     */
    setTimeout(timeout?: number): QueryPayload;
    /**
     * An optional parameter which is used for defining the request Content-Type.
     * @param [contentType] - One of the supported content types for given
     * operation.
     */
    setContentType(contentType?: string): QueryPayload;
    /**
     * @returns content type which was populated in this payload.
     */
    getContentType(): string;
    /**
     * Serializes all query parameters populated in the payload. Only parameters
     * which are present will be returned.
     *
     * Mandatory and dependent parameters are validated and errors are thrown if
     * necessary.
     * @returns a serialized payload which holds all available query
     * parameters in this payload object.
     */
    getParams(): string;
    /**
     * Utility method which serializes a single level json object to properly
     * encoded string that can be used in a request.
     * @param data - object which holds request parameter key:value pairs.
     * @returns provided object serialized and encoded to string.
     */
    protected serialize(data: any): string;
    /**
     * Must be implemented in successors.
     *
     * Validates payload for mandatory and invalid parameters.
     * @returns <code>true</code> if parameters are valid and
     * <code>false</code> otherwise.
     */
    protected validateParams(): boolean;
    /**
     * Must be implemented in successors and should return a list with supported
     * content types.
     */
    protected getSupportedContentTypes(): string[];
}

/**
 * Supported RDF query types.
 */
declare const enum QueryType {
    SELECT = "SELECT",
    CONSTRUCT = "CONSTRUCT",
    DESCRIBE = "DESCRIBE",
    ASK = "ASK"
}

/**
 * Constructs this payload class.
 */
declare class UpdateQueryPayload {
    /**
     * @param query - The query as string to be evaluated.
     */
    setQuery(query: string): UpdateQueryPayload;
    /**
     * @returns a query which was populated in the payload.
     */
    getQuery(): string;
    /**
     * One or more named graph URIs to be used as default graph(s) for retrieving.
     */
    setDefaultGraphs(defaultGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @returns Default graphs for the query for retrieving.
     */
    getDefaultGraphs(): string | string[];
    /**
     * One or more named graph URIs to be used as named graph(s) for retrieving.
     */
    setNamedGraphs(namedGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @returns Named graphs set for the query for retrieving.
     */
    getNamedGraphs(): string | string[];
    /**
     * One or more default graphs for removing statements.
     */
    setRemoveGraphs(removeGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @returns Default graphs set for the query for removing.
     */
    getRemoveGraphs(): string | string[];
    /**
     * One or more default graphs for inserting statements.
     */
    setInsertGraphs(insertGraphs?: string | string[]): UpdateQueryPayload;
    /**
     * @returns Default graphs set for the query for inserting.
     */
    getInsertGraphs(): string | string[];
    validateParams(): void;
    getSupportedContentTypes(): void;
}

/**
 * Object builder used for constructing a statement addition payload.
 */
declare class AddStatementPayload {
    /**
     * Sets the language this statement's object.
     *
     * This makes the statement a literal.
     * @param [language] - the object's language
     * @returns the payload for method chaining
     */
    setLanguage(language?: string): AddStatementPayload;
    /**
     * Returns the statement object's language.
     *
     * Having a language means it is a literal.
     * @returns the language
     */
    getLanguage(): string;
    /**
     * Sets the data type this statement's object.
     *
     * This makes the statement a literal.
     * @param [dataType] - the object's data type
     * @returns the payload for method chaining
     */
    setDataType(dataType?: string): AddStatementPayload;
    /**
     * Returns the statement object's data type.
     *
     * Having a data type means it is a literal.
     * @returns the data type
     */
    getDataType(): string;
    /**
     * Sets the statement's object value making it a literal.
     *
     * If the data type is not provided, it will try to autodetect it:
     * <ul>
     *   <li>integer -> xsd:integer</li>
     *   <li>float -> xsd:decimal</li>
     *   <li>boolean -> xsd:boolean</li>
     * </ul>
     * Everything else will be considered as xsd:string.
     *
     * To set a language the data type must be xsd:string.
     * @param value - the statements object value
     * @param [type] - the statements object data type
     * @param [language] - the statements object language
     * @returns the payload for method chaining
     */
    setObjectLiteral(value: any, type?: string, language?: string): AddStatementPayload;
    /**
     * Returns if this statement payload is for a literal. A literal have
     * data type and/or language.
     * @returns <code>true</code> if it is a literal payload or
     * <code>false</code> otherwise
     */
    isLiteral(): boolean;
    /**
     * Sets the base URI that is used for resolving any relative URIs in the
     * current payload.
     * @param baseURI - the base URI
     * @returns the payload for method chaining
     */
    setBaseURI(baseURI: string): AddStatementPayload;
    /**
     * Returns the base URI that is used for resolving any relative URIs.
     * @returns the base URI
     */
    getBaseURI(): string;
}

/**
 * Set of HTTP status codes for which requests could be re-attempted.
 */
declare const RETRIABLE_STATUSES: number[];

/**
 * Constructs a repository client with the provided configuration.
 */
declare class BaseRepositoryClient {
    constructor(repositoryClientConfig: RepositoryClientConfig);
    /**
     * Gets a logger instance.
     * @returns the logger instance
     */
    getLogger(): Logger;
    /**
     * Register provided parser in the internal parser registry.
     * @param parser - implementation wrapper.
     */
    registerParser(parser: ContentParser): void;
    /**
     * Parses provided content with registered parser if there is one. Otherwise
     * returns the content untouched. If <code>contentType</code> is provided it
     * should be an instance of {@link RDFMimeType} enum and is used as a key
     * for selecting appropriate parser from the parsers registry.
     * Parsing is done synchronously!
     * @param [parserConfig] - optional parser configuration
     */
    protected parse(content: string, responseType: string, parserConfig?: any): string | Term | Term[];
    /**
     * Executor for http requests. It passes the provided HTTP request builder
     * to a HTTP client for executing requests.
     *
     * If the request was unsuccessful it will be retried with another endpoint
     * HTTP client in case the request's status is one of
     * {@link RETRIABLE_STATUSES} or if the host is currently unreachable.
     *
     * If all of the endpoints are unsuccessful then the execution will fail
     * with promise rejection.
     * @param requestBuilder - the http request data to be
     * passed to a http client
     * @returns a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */
    protected execute(requestBuilder: HttpRequestBuilder): Promise<HttpResponse | Error>;
    /**
     * Creates an object from the provided HTTP response that is suitable for
     * structured logging.
     *
     * Any additional key-value entries from <code>params</code> will be assigned
     * in the created payload object.
     * @param response - the HTTP response.
     * Used to get the execution time and the base URL
     * @param [params] - additional parameters to be appended
     * @returns the constructed payload object for logging
     */
    protected getLogPayload(response: HttpResponse, params?: any): any;
    /**
     * Logged user getter.
     * @returns user
     */
    getLoggedUser(): User;
    /**
     * User setter
     */
    setLoggedUser(user: User): BaseRepositoryClient;
}

/**
 * Constructs this payload class populating some reasonable defaults.
 */
declare class GetStatementsPayload {
    /**
     * @param [inference] - defines if inferred statements should be
     *      included in the result of GET requests.
     */
    setInference(inference?: boolean): GetStatementsPayload;
    /**
     * @returns inference
     */
    getInference(): boolean;
    /**
     * Sets responseType parameter.
     */
    setResponseType(responseType?: RDFMimeType): GetStatementsPayload;
    /**
     * @returns responseType
     */
    getResponseType(): string;
}

/**
 * RDF repository client implementation realizing specific operations.
 */
declare class RDFRepositoryClient {
    constructor(repositoryClientConfig: RepositoryClientConfig);
    getLogger(): void;
    /**
     * Instantiates dependent services.
     */
    initServices(): void;
    /**
     * Retrieves the size of the repository.
     *
     * Effectively returns how much statements are in the repository.
     *
     * If one or multiple context are provided, the operation will be restricted
     * upon each of them.
     * @param [context] - context or contexts to restrict the
     * size calculation. Will be encoded as N-Triple if it is not already one
     * @returns a promise resolving to the total number of
     *                           statements in the repository
     */
    getSize(context?: string | string[]): Promise<number>;
    /**
     * Retrieves all present namespaces as a collection of {@link Namespace}.
     * @returns promise resolving to a collection of
     *                                {@link Namespace}
     */
    getNamespaces(): Promise<Namespace[]>;
    /**
     * Retrieves the namespace for the given prefix as {@link NamedNode}.
     *
     * For example if <code>rdfs</code> is provided as prefix that would result in
     * a {@link NamedNode} corresponding to following namespace:
     * <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     * @param prefix - prefix of the namespace to be retrieved
     * @returns promise resolving to {@link NamedNode}
     */
    getNamespace(prefix: string): Promise<NamedNode>;
    /**
     * Creates or updates the namespace for the given prefix.
     *
     * If the provided prefix or namespace parameter is not a string or
     * {@link NamedNode} then the method will throw an error.
     * @param prefix - prefix of the namespace to be created/updated
     * @param namespace - the namespace to be created/updated
     * @returns promise that will be resolved if the create/update
     * request is successful
     */
    saveNamespace(prefix: string, namespace: string | NamedNode): Promise<void>;
    /**
     * Deletes a namespace that corresponds to the given prefix.
     *
     * For example if <code>rdfs</code> is provided as prefix that would delete
     * the following namespace: <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     * @param prefix - prefix of the namespace to be deleted
     * @returns promise that will be resolved if the deletion is
     * successful
     */
    deleteNamespace(prefix: string): Promise<void>;
    /**
     * Deletes all namespace declarations in the repository.
     * @returns promise that will be resolved after
     * successful deletion
     */
    deleteNamespaces(): Promise<void>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     * @param payload - is an object holding the request
     * parameters.
     * @returns resolves with plain string or Quad according
     *      to provided response type.
     */
    get(payload: GetStatementsPayload): Promise<string | Quad>;
    /**
     * Executes request to query a repository.
     *
     * Only POST request with a valid QueryPayload is supported.
     * @param payload - is an object holding request parameters
     * required by the query POST endpoint.
     * @returns the client can subscribe to the stream events and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     */
    query(payload: GetQueryPayload): Promise;
    /**
     * Executes a request with a sparql query against <code>/statements</code>
     * endpoint to update repository data.
     *
     * If <code>contentType</code> is set to
     * <code>application/x-www-form-urlencoded</code> then query and request
     * parameters from the payload are encoded as query string and sent as request
     * body.
     *
     * If <code>contentType</code> is set to
     * <code>application/sparql-update</code> then the query is sent unencoded as
     * request body.
     * @returns promise that will be resolved if the update is
     * successful or rejected in case of failure
     */
    update(payload: UpdateQueryPayload): Promise<void>;
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     * @param payload - holding request parameters
     * @returns promise that will be resolved if the addition is
     * successful or rejected in case of failure
     */
    add(payload: AddStatementPayload): Promise<void>;
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     * @param quads - collection of quads to be sent as Turtle/Trig text
     * @param [context] - restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns promise that will be resolved if the addition is
     * successful or rejected in case of failure
     */
    addQuads(quads: Quad[], context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Overwrites the repository's data by serializing the provided quads to
     * Turtle format and sending them to the repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * The overwrite will be restricted if the context parameter is specified.
     * @param quads - collection of quads to be sent as Turtle/Trig text
     * @param [context] - restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns promise that will be resolved if the overwrite is
     * successful or rejected in case of failure
     */
    putQuads(quads: Quad[], context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Deletes statements in the repository based on the provided subject,
     * predicate, object and or contexts. Each of them is optional and acts as
     * statements filter which effectively narrows the scope of the deletion.
     *
     * Providing context or contexts will restricts the operation to one or more
     * specific contexts in the repository.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     * @param [subject] - resource subject
     * @param [predicate] - resource predicate
     * @param [object] - resource object
     * @param [contexts] - resource or resources context
     * @returns promise that will be resolved if the deletion is
     *                         successful or rejected in case of failure
     */
    deleteStatements(subject?: string, predicate?: string, object?: string, contexts?: String[] | string): Promise<void>;
    /**
     * Deletes all statements in the repository.
     * @returns promise that will be resolved if the deletion is
     *                   successful or rejected in case of failure
     */
    deleteAllStatements(): Promise<void>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     * @param payload - is an object holding request params
     * @returns the client can subscribe to the readable
     * stream events and consume the emitted strings depending on the provided
     * response type as soon as they are available.
     */
    download(payload: GetStatementsPayload): Promise<WritableStream>;
    /**
     * Executes a POST request against the <code>/statements</code> endpoint. The
     * statements which have to be added are provided through a readable stream.
     * This method is useful for library client who wants to upload a big data set
     * into the repository.
     * @param contentType - is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param [context] - optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - optional uri against which any relative URIs
     * found in the data would be resolved.
     * @returns a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */
    upload(readStream: ReadableStream, contentType: string, context?: NamedNode | string, baseURI?: string): Promise<void>;
    /**
     * Executes a PUT request against the <code>/statements</code> endpoint. The
     * statements which have to be updated are provided through a readable stream.
     * This method is useful for overriding large set of statements that might be
     * provided as a readable stream e.g. reading from file.
     * @param context - restrict the operation. Will be encoded
     * as N-Triple if it is not already one
     * @param [baseURI] - optional uri against which any relative URIs
     * found in the data would be resolved.
     * @returns a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */
    overwrite(readStream: ReadableStream, contentType: string, context: NamedNode | string, baseURI?: string): Promise<void>;
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     * @param filePath - path to a file to be streamed to the server
     * @param contentType - MIME type of the file's content
     * @param [context] - restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns a promise that will be resolved when the file has
     * been successfully consumed by the server
     */
    addFile(filePath: string, contentType: string, context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Uploads the file specified by the provided file path to the server
     * overwriting any data in the server's repository.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * See {@link #overwrite}
     * @param filePath - path to a file to be streamed to the server
     * @param contentType - MIME type of the file's content
     * @param [context] - restricts the operation to the given context.
     * Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns a promise that will be resolved when the file has
     * been successfully consumed by the server
     */
    putFile(filePath: string, contentType: string, context?: string, baseURI?: string): Promise<void>;
    /**
     * Starts a transaction and produces a {@link TransactionalRepositoryClient}.
     *
     * The transactions ID is extracted from the <code>location</code> header and
     * is used as  endpoint for the produced TransactionalRepositoryClient.
     *
     * If no transaction isolation level is provided, the server will use its
     * default isolation level.
     * @param [isolationLevel] - an optional parameter to specify the
     * transaction's level of isolation; for possible values  see
     * {@link TransactionIsolationLevel}
     * @returns transactional client
     */
    beginTransaction(isolationLevel?: string): Promise<TransactionalRepositoryClient>;
}

/**
 * Repository client configuration constructor.
 * Initializes [endpoints]{@link RepositoryClientConfig#endpoints} and
 * sets configuration default values to
 * [defaultRDFMimeType]{@link RepositoryClientConfig#defaultRDFMimeType},
 * [readTimeout]{@link RepositoryClientConfig#readTimeout} and
 * [writeTimeout]{@link RepositoryClientConfig#writeTimeout}
 * @param endpoint - server base URL that will be prepend
 * to all server requests
 */
declare class RepositoryClientConfig extends ClientConfig {
    constructor(endpoint: string);
    /**
     * Sets the repository endpoint URLs.
     * @param endpoints - the endpoint URLs
     * @returns current config for method chaining
     */
    setEndpoints(endpoints: string[]): this;
    /**
     * Inserts a repository endpoint URL to the rest of the endpoints.
     * @param endpoint - repository endpoint URL
     * @returns current config for method chaining
     */
    addEndpoint(endpoint: string): this;
    /**
     * Gets the repository endpoint URLs.
     */
    getEndpoints(): string[];
    /**
     * Sets the default RDF MIME type.
     * @returns current config for method chaining
     */
    setDefaultRDFMimeType(defaultRDFMimeType: string): this;
    /**
     * Returns the default RDF MIME type.
     */
    getDefaultRDFMimeType(): string;
    /**
     * Sets the default read timeout for HTTP requests.
     * @param readTimeout - the timeout in milliseconds
     * @returns current config for method chaining
     */
    setReadTimeout(readTimeout: number): this;
    /**
     * Returns the default read timeout for HTTP requests.
     */
    getReadTimeout(): number;
    /**
     * Sets the default write timeout for HTTP requests.
     * @param writeTimeout - the timeout in milliseconds
     * @returns current config for method chaining
     */
    setWriteTimeout(writeTimeout: number): this;
    /**
     * Returns the default write timeout for HTTP requests.
     */
    getWriteTimeout(): number;
    /**
     * Sets the default headers map for each HTTP request.
     * @param headers - the default headers
     * @returns the concrete configuration config for method chaining
     */
    setHeaders(headers: {
        [key: string]: string;
    }): this;
    /**
     * Returns the default headers for each HTTP request.
     * @returns the default headers map
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * @returns the username
     */
    getUsername(): string;
    /**
     * @returns the user password
     */
    getPass(): string;
    /**
     * @returns if the user should be re-logged in after token expires
     */
    getKeepAlive(): boolean;
    /**
     * @returns the concrete configuration config for method chaining
     */
    setKeepAlive(keepAlive: boolean): this;
    /**
     * Username and password for user logging setter.
     * Sets basic authentication as client authentication type.
     * @returns the concrete configuration config for method chaining
     */
    useBasicAuthentication(username?: string, pass?: string): this;
    /**
     * @returns [basicAuth] if use Basic Auth
     */
    getBasicAuthentication(): boolean;
    /**
     * @returns [gdbTokenAuth] if use Gdb Token Auth
     */
    getGdbTokenAuthentication(): boolean;
    /**
     * Username and password for user logging setter.
     * Sets gdb token authentication as client authentication type.
     * *
     * @returns the concrete configuration config for method chaining
     */
    useGdbTokenAuthentication(username?: string, pass?: string): this;
    /**
     * Disables authentication.
     */
    disableAuthentication(): void;
    /**
     * Sets the server's endpoint URL.
     * @param endpoint - the endpoint URL
     * @returns the current config for method chaining
     */
    setEndpoint(endpoint: string): this;
    /**
     * Returns the server's endpoint URL.
     * @returns the endpoint URL
     */
    getEndpoint(): string;
    /**
     * Returns <code>true</code> if basic or gdb token authentication
     * is enabled. <code>false</code> otherwise.
     * @returns is authentication enabled
     */
    shouldAuthenticate(): boolean;
}

/**
 * Supported repository types
 */
declare const enum RepositoryType {
    SE = "se",
    MASTER = "master",
    WORKER = "worker",
    FREE = "free",
    ONTOP = "ontop"
}

/**
 * Instantiates new statement payload.
 */
declare class StatementPayload {
    setSubject(subject?: string): StatementPayload;
    /**
     * @returns subject
     */
    getSubject(): string;
    setPredicate(predicate?: string): StatementPayload;
    /**
     * @returns predicate
     */
    getPredicate(): string;
    setObject(object?: string): StatementPayload;
    /**
     * @returns object
     */
    getObject(): string;
    setContext(context?: string | string[]): StatementPayload;
    /**
     * @returns context
     */
    getContext(): string;
    /**
     * Get the payload object.
     */
    get(): any;
}

/**
 * Defines a wrapper around query result which can be fetched in
 * pages, defining pagination configuration and holding reference
 * to {@link BaseRepositoryClient} used internally for the fetch
 * operations.
 */
declare class PagedResponse {
    constructor(repository: BaseRepositoryClient, total: number, offset: number, limit: number, responseType: RDFMimeType, result: string | sparql | ResponseIterator);
}

/**
 * Defines a wrapper around chunked response allowing consuming the response
 * on demand.
 */
declare class ResponseIterator {
}

/**
 * Factory to create concrete authentication type, based on
 * client configuration.
 */
declare class AuthenticationFactory {
    /**
     * Concrete authentication type generator.
     */
    getAuthenticationType(clientConfig: ClientConfig): BasicAuthentication | GdbTokenAuthentication;
}

/**
 * Authority roles.
 */
declare const enum Authority {
    ADMIN = "Admin",
    REPO_MANAGER = "RepoManager",
    USER = "User",
    READ_REPO_PREFIX = "Read_REPO_",
    WRITE_REPO_PREFIX = "Write_REPO_"
}

/**
 * Basic authentication type class.
 * Used for basic authentication against secured gdb server.
 */
declare class BasicAuthentication {
    /**
     * @returns requestBuilder
     */
    getLoginRequestBuilder(): HttpRequestBuilder;
    /**
     * @returns token
     */
    getResponseAuthToken(): string;
}

/**
 * Gdb token authentication type class.
 * Used for gdb token authentication against secured gdb server.
 */
declare class GdbTokenAuthentication {
    /**
     * @returns requestBuilder
     */
    getLoginRequestBuilder(): HttpRequestBuilder;
    /**
     * @returns token
     */
    getResponseAuthToken(): string;
}

/**
 * Implementation of the graphDB server operations.
 *
 *  Used to automate the security user management API:
 *  add, edit, or remove users.  Also used to add, edit,
 *  or remove a repository to/from any attached location.
 *  You can work with multiple remote locations from a
 *  single access point.
 * @param config - for the server client.
 */
declare class GraphDBServerClient {
    constructor(config: ServerClientConfig);
    /**
     * Get the default repository configuration for the repository type
     * @param repositoryType - the type for which a
     * default configuration is required
     * @returns a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */
    getDefaultConfig(repositoryType: RepositoryType | string): Promise<HttpResponse | Error>;
    /**
     * Get the repository configuration
     * @param repositoryId - the repository id
     * @param [location] - optional repository location
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    getRepositoryConfig(repositoryId: string, location?: string): Promise<HttpResponse | string | Error>;
    /**
     * Download the repository configuration in turtle format
     * @param repositoryId - the repository id
     * @param [location] - optional repository location
     * @returns a service request that will resolve to a
     * readable stream to which the client can subscribe and consume the emitted
     * strings as soon as they are available. Resolves to turtle format.
     */
    downloadRepositoryConfig(repositoryId: string, location?: string): Promise<string | any>;
    /**
     * Create repository according to the provided configuration
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    createRepository(repositoryConfig: RepositoryConfig): Promise<HttpResponse | Error>;
    /**
     * Delete repository with the provided id.
     * @param id - of the repository which should be deleted.
     * @returns promise which resolves with the delete result.
     */
    deleteRepository(id: string): Promise<any>;
    /**
     * Checks if GraphDB security is enabled.
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    isSecurityEnabled(): Promise<HttpResponse | Error>;
    /**
     * Enable or disable GraphDB security.
     * @param enabled - <code>true</code> if security is enabled and
     * <code>false</code> otherwise.
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    toggleSecurity(enabled: boolean): Promise<HttpResponse | Error>;
    /**
     * Enable or disable access to a predefined set of functionalities
     * without having to log in.
     * To use free access, you must have security enabled.
     * Use with extreme caution, as the changes that are made to the
     * application settings may possibly change the behavior of the
     * GraphDB Workbench for the logged-in user or for all users
     * if logged in as admin.
     * @param enabled - <code>true</code> if free access is enabled and
     * <code>false</code> otherwise.
     * @param authorities - Array of read and/or write access rights
     * described in the following template:
     * <code>READ_REPO_{repository ID}</code> to grant repository read rights
     * <code>WRITE_REPO_{repository ID}</code> to grant repository write rights
     * @param appSettings - configure the default behavior
     * of the GraphDB Workbench
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    updateFreeAccess(enabled: boolean, authorities: string[], appSettings: AppSettings): Promise<HttpResponse | Error>;
    /**
     * Check if free access is enabled
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    getFreeAccess(): Promise<HttpResponse | Error>;
    /**
     * Create a user
     * @param username - User name
     * @param password - User password
     * @param [grantedAuthorities] - Array of read and/or write access
     * rights described in the following template:
     * <code>READ_REPO_{repository ID}</code> to grant repository read rights
     * <code>WRITE_REPO_{repository ID}</code> to grant repository write rights
     * @param [appSettings] - configure the default behavior
     * of the GraphDB Workbench
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    createUser(username: string, password: string, grantedAuthorities?: string[], appSettings?: AppSettings): Promise<HttpResponse | Error>;
    /**
     * Edit user.
     * Use with extreme caution, as the changes that are made to the
     * application settings may possibly change the behavior of the
     * GraphDB Workbench for the user.
     * @param username - User name
     * @param [password] - User password
     * @param [grantedAuthorities] - Array of read and/or write access
     * rights described in the following template:
     * <code>READ_REPO_{repository ID}</code> to grant repository read rights
     * <code>WRITE_REPO_{repository ID}</code> to grant repository write rights
     * @param [appSettings] - configure the default behavior
     * of the GraphDB Workbench
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    updateUser(username: string, password?: string, grantedAuthorities?: string[], appSettings?: AppSettings): Promise<HttpResponse | Error>;
    /**
     * Change setting for a logged user.
     * Use with extreme caution, as the changes that are made to the
     * application settings may possibly change the behavior of the
     * GraphDB Workbench for the user.
     * @param username - User name
     * @param [password] - User password
     * @param [appSettings] - configure the default behavior
     * of the GraphDB Workbench
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    updateUserData(username: string, password?: string, appSettings?: AppSettings): Promise<HttpResponse | Error>;
    /**
     * Get a user
     * @param username - User name
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    getUser(username: string): Promise<HttpResponse | Error>;
    /**
     * Deletes a user
     * @param username - User name
     * @returns a promise which resolves
     * to response wrapper or rejects with error if thrown during execution.
     */
    deleteUser(username: string): Promise<HttpResponse | Error>;
}

/**
 * Server client configuration constructor.
 * Sets configuration default value to
 * [timeout]{@link ServerClientConfig#timeout}
 * and [keepAlive]{@link ServerClientConfig#keepAlive}
 * @param [endpoint] - Endpoint url.
 */
declare class ServerClientConfig extends ClientConfig {
    constructor(endpoint?: string);
    /**
     * Sets the timeout for HTTP requests.
     * @param timeout - the timeout in milliseconds before the
     * request times out.
     * @returns the concrete configuration config for method chaining
     */
    setTimeout(timeout: number): this;
    /**
     * Returns the HTTP requests's timeout.
     * @returns the timeout in milliseconds
     */
    getTimeout(): number;
    /**
     * Sets the default headers map for each HTTP request.
     * @param headers - the default headers
     * @returns the concrete configuration config for method chaining
     */
    setHeaders(headers: {
        [key: string]: string;
    }): this;
    /**
     * Returns the default headers for each HTTP request.
     * @returns the default headers map
     */
    getHeaders(): {
        [key: string]: string;
    };
    /**
     * @returns the username
     */
    getUsername(): string;
    /**
     * @returns the user password
     */
    getPass(): string;
    /**
     * @returns if the user should be re-logged in after token expires
     */
    getKeepAlive(): boolean;
    /**
     * @returns the concrete configuration config for method chaining
     */
    setKeepAlive(keepAlive: boolean): this;
    /**
     * Username and password for user logging setter.
     * Sets basic authentication as client authentication type.
     * @returns the concrete configuration config for method chaining
     */
    useBasicAuthentication(username?: string, pass?: string): this;
    /**
     * @returns [basicAuth] if use Basic Auth
     */
    getBasicAuthentication(): boolean;
    /**
     * @returns [gdbTokenAuth] if use Gdb Token Auth
     */
    getGdbTokenAuthentication(): boolean;
    /**
     * Username and password for user logging setter.
     * Sets gdb token authentication as client authentication type.
     * *
     * @returns the concrete configuration config for method chaining
     */
    useGdbTokenAuthentication(username?: string, pass?: string): this;
    /**
     * Disables authentication.
     */
    disableAuthentication(): void;
    /**
     * Sets the server's endpoint URL.
     * @param endpoint - the endpoint URL
     * @returns the current config for method chaining
     */
    setEndpoint(endpoint: string): this;
    /**
     * Returns the server's endpoint URL.
     * @returns the endpoint URL
     */
    getEndpoint(): string;
    /**
     * Returns <code>true</code> if basic or gdb token authentication
     * is enabled. <code>false</code> otherwise.
     * @returns is authentication enabled
     */
    shouldAuthenticate(): boolean;
}

/**
 * Implementation of the server operations.
 *
 * If the server against which this client will be used has security enabled,
 * then it should be configured with the username and password in the
 * {@link ServerClientConfig}. In this case a login attempt is made before any
 * API method to be executed. Upon successful login an {@link User} which holds
 * the credentials and the authorization token in the context of the client is
 * created. In all consecutive API calls the authorization token is sent as a
 * http header.
 *
 * By default {@link ServerClientConfig} is configured with
 * <code>keepAlive = true</code> which means that upon authorization token
 * expiration current logged in user would be re-logged automatically before
 * next API call. This configuration can be changed within the configuration.
 * @param config - for the server client.
 */
declare class ServerClient {
    constructor(config: ServerClientConfig);
    /**
     * Get an array of repository ids available in the server.
     * @returns promise which resolves with an Array with
     * repository ids.
     */
    getRepositoryIDs(): Promise<any[]>;
    /**
     * Check if repository with the provided id exists.
     * @param id - of the repository which should be checked.
     * @returns promise which resolves with boolean value.
     */
    hasRepository(id: string): Promise<boolean>;
    /**
     * Creates a repository client instance with the provided id and
     * configuration.
     * @param id - of the repository
     * @param config - for the overridable repository
     *    configuration.
     * @returns promise which resolves with
     *    new RDFRepositoryClient instance.
     */
    getRepository(id: string, config: RepositoryClientConfig): Promise<RDFRepositoryClient>;
    /**
     * Delete repository with the provided id.
     * @param id - of the repository which should be deleted.
     * @returns promise which resolves with the delete result.
     */
    deleteRepository(id: string): Promise<any>;
    /**
     * Initializes the http client.
     */
    initHttpClient(): void;
    /**
     * Initializes the logger.
     */
    initLogger(): void;
    /**
     * Executes http request wrapped in provided request builder.
     * If the server config provides username and password, then a logging attempt
     * is made. Upon successful login the auth data is stored for later requests.
     * @returns a promise which resolves to response
     * wrapper or rejects with error if thrown during execution.
     */
    public execute(requestBuilder: HttpRequestBuilder): Promise<HttpResponse | Error>;
    /**
     * Logged user getter.
     * @returns user
     */
    getLoggedUser(): User;
    /**
     * User setter
     */
    setLoggedUser(user: User): ServerClient;
}

/**
 * Instantiates the service with the provided HTTP request executor.
 * @param [httpClient] - used to execute HTTP requests
 */
declare class AuthenticationService {
    constructor(httpClient?: HttpClient);
    /**
     * Performs a login request against secured server with provided username and
     * password. Upon successful authentication a {@link User} instance is created
     * with the user data and the auth token and returned to the client.
     * @param clientConfig - concrete client configuration
     * @param user - logged in user
     * @returns a promise resolving to an authenticated
     * {@link User} instance.
     */
    login(clientConfig: ClientConfig, user: User): Promise<User>;
    /**
     * Performs a logout of logged in user. This effectively removes the stored in
     * the client user. Every consecutive call against secured server will result
     * in <code>Unauthorized</code> error with status code <code>401</code>.
     * @param user - logged in user
     * @returns returns a promise which resolves with undefined.
     */
    logout(user: User): Promise;
    /**
     * Return an effective valid token as string which is going to be send as a
     * request header <code>Authorization: token</code>. If there is no logged in
     * user, then this method returns <code>undefined</code>.
     * @param user - logged in user
     * @returns authentication token
     */
    getAuthenticationToken(user: User): string | undefined;
    /**
     * Returns authentication type related {@link HttpRequestBuilder}
     * login request builder
     * @param clientConfig - concrete client configuration
     * @returns request builder
     */
    getLoginRequest(clientConfig: ClientConfig): HttpRequestBuilder;
    /**
     * Authentication type getter
     * @param clientConfig - concrete client configuration
     * @returns concrete
     * authentication type
     */
    getAuthentication(clientConfig: ClientConfig): BasicAuthentication | GdbTokenAuthentication;
}

/**
 * Service for downloading data via {@link GetStatementsPayload}.
 */
declare class DownloadService {
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     * @param payload - is an object holding request params
     * @returns a service request that will resolve to a readable
     * stream to which the client can subscribe and consume the emitted strings
     * depending on the provided response type as soon as they are available.
     */
    download(payload: GetStatementsPayload): ServiceRequest;
    getServiceName(): void;
}

/**
 * Service for namespace management.
 */
declare class NamespaceService {
    /**
     * Retrieves all present namespaces as a collection of {@link Namespace}.
     * @returns a service request resolving to a collection of
     * {@link Namespace}
     */
    getNamespaces(): ServiceRequest;
    /**
     * Retrieves the namespace for the given prefix as {@link NamedNode}.
     *
     * For example if <code>rdfs</code> is provided as prefix that would result in
     * a {@link NamedNode} corresponding to following namespace:
     * <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     * @param prefix - prefix of the namespace to be retrieved
     * @returns service request resolving to {@link NamedNode}
     */
    getNamespace(prefix: string): ServiceRequest;
    /**
     * Creates or updates the namespace for the given prefix.
     *
     * If the provided prefix or namespace parameter is not a string or
     * {@link NamedNode} then the method will throw an error.
     * @param prefix - prefix of the namespace to be created/updated
     * @param namespace - the namespace to be created/updated
     * @returns service request that will be resolved if the
     * create/update request is successful
     */
    saveNamespace(prefix: string, namespace: string | NamedNode): ServiceRequest;
    /**
     * Deletes a namespace that corresponds to the given prefix.
     *
     * For example if <code>rdfs</code> is provided as prefix that would delete
     * the following namespace: <code>http://www.w3.org/2000/01/rdf-schema#</code>
     *
     * Note: This method should be invoked only with prefixes. Anything else would
     * result in an error from the server.
     * @param prefix - prefix of the namespace to be deleted
     * @returns promise that will be resolved if the deletion is
     * successful
     */
    deleteNamespace(prefix: string): Promise<void>;
    /**
     * Deletes all namespace declarations in the repository.
     * @returns promise that will be resolved after
     * successful deletion
     */
    deleteNamespaces(): Promise<void>;
    getServiceName(): void;
}

/**
 * Instantiates the query service.
 * @param httpRequestExecutor - used to execute HTTP requests
 * @param parseExecutor - function that will parse provided data
 */
declare class QueryService {
    constructor(httpRequestExecutor: (...params: any[]) => any, parseExecutor: (...params: any[]) => any);
    /**
     * Executes request to query a repository.
     *
     * Only POST request with a valid QueryPayload is supported.
     * @param payload - is an object holding request parameters
     * required by the query POST endpoint.
     * @returns a service request that will resolve to a readable
     * stream to which the client can subscribe and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     */
    query(payload: GetQueryPayload): ServiceRequest;
    /**
     * Executes a request with a sparql query against <code>/statements</code>
     * endpoint to update repository data.
     *
     * If <code>contentType</code> is set to
     * <code>application/x-www-form-urlencoded</code> then query and request
     * parameters from the payload are encoded as query string and sent as request
     * body.
     *
     * If <code>contentType</code> is set to
     * <code>application/sparql-update</code> then the query is sent unencoded as
     * request body.
     * @returns service request that will be resolved if the
     * update is successful or rejected in case of failure
     */
    update(payload: UpdateQueryPayload): ServiceRequest;
    getServiceName(): void;
}

/**
 * Service for working repositories.
 */
declare class RepositoryService {
    /**
     * Retrieves the size of the repository.
     *
     * Effectively returns how much statements are in the repository.
     *
     * If one or multiple context are provided, the operation will be restricted
     * upon each of them.
     * @param [context] - context or contexts to restrict the
     * size calculation. Will be encoded as N-Triple if it is not already one
     * @returns a service request resolving to the total number of
     * statements in the repository
     */
    getSize(context?: string | string[]): ServiceRequest;
    getServiceName(): void;
}

/**
 * Defines a path segment for statements REST endpoint
 */
declare const PATH_STATEMENTS = "/statements";

/**
 * Defines the path segment for namespaces REST endpoint
 */
declare const PATH_NAMESPACES = "/namespaces";

/**
 * Defines a path segment for transactions REST endpoint.
 */
declare const PATH_TRANSACTIONS = "/transactions";

/**
 * Defines a path segment for size REST endpoint.
 */
declare const PATH_SIZE = "/size";

/**
 * Instantiates the request with the supplied builder and executor.
 * @param httpRequestBuilder - builder carrying
 * the request data and params
 * @param requestExecutor - executor for HTTP requests
 */
declare class ServiceRequest {
    constructor(httpRequestBuilder: HttpRequestBuilder, requestExecutor: (...params: any[]) => any);
    /**
     * Returns the request builder.
     */
    getHttpRequestBuilder(): HttpRequestBuilder;
    /**
     * Triggers service request execution.
     */
    execute(): Promise;
}

/**
 * Instantiates the service with the provided HTTP request executor function.
 * @param httpRequestExecutor - used to execute HTTP requests
 */
declare class Service {
    constructor(httpRequestExecutor: (...params: any[]) => any);
    /**
     * Returns the service's name.
     * @returns the name
     */
    getServiceName(): string;
}

/**
 * Instantiates the service with the supplied executor and parser utils.
 * @param httpRequestExecutor - executor for HTTP requests
 * @param parserRegistry - registry of available parsers
 * @param parseExecutor - function that will parse provided data
 */
declare class StatementsService {
    constructor(httpRequestExecutor: (...params: any[]) => any, parserRegistry: ParserRegistry, parseExecutor: (...params: any[]) => any);
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     * @param payload - is an object holding the request
     * parameters.
     * @returns service request that resolves to plain string or
     * Quad according to provided response type.
     */
    get(payload: GetStatementsPayload): ServiceRequest;
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     * @param payload - holding request parameters
     * @returns service request that will resolve if the addition
     * is successful or reject in case of failure
     */
    add(payload: AddStatementPayload): ServiceRequest;
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     * @param quads - collection of quads to be sent as Turtle/Trig text
     * @param [context] - restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns service request that will be resolved if the
     * addition is successful or rejected in case of failure
     */
    addQuads(quads: Quad[], context?: string | string[], baseURI?: string): ServiceRequest;
    /**
     * Overwrites the repository's data by serializing the provided quads to
     * Turtle format and sending them to the repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * The overwrite will be restricted if the context parameter is specified.
     * @param quads - collection of quads to be sent as Turtle/Trig text
     * @param [context] - restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns service request that will be resolved if the
     * overwrite is successful or rejected in case of failure
     */
    putQuads(quads: Quad[], context?: string | string[], baseURI?: string): ServiceRequest;
    /**
     * Deletes statements in the repository based on the provided subject,
     * predicate, object and or contexts. Each of them is optional and acts as
     * statements filter which effectively narrows the scope of the deletion.
     *
     * Providing context or contexts will restricts the operation to one or more
     * specific contexts in the repository.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     * @param [subject] - resource subject
     * @param [predicate] - resource predicate
     * @param [object] - resource object
     * @param [contexts] - resource or resources context
     * @returns service request that will be resolved if the
     * deletion is successful or rejected in case of failure
     */
    deleteStatements(subject?: string, predicate?: string, object?: string, contexts?: String[] | string): ServiceRequest;
    /**
     * Deletes all statements in the repository.
     * @returns service request that will be resolved if the
     * deletion is successful or rejected in case of failure
     */
    deleteAllStatements(): ServiceRequest;
    getServiceName(): void;
}

/**
 * Instantiates the transaction service with the supplied executor and
 * repository client config.
 * @param httpRequestExecutor - used to execute HTTP requests
 * @param repositoryClientConfig - used to create
 * transaction client configurations
 */
declare class TransactionService {
    constructor(httpRequestExecutor: (...params: any[]) => any, repositoryClientConfig: RepositoryClientConfig);
    /**
     * Starts a transaction and produces a {@link TransactionalRepositoryClient}.
     *
     * The transactions ID is extracted from the <code>location</code> header and
     * is used as  endpoint for the produced TransactionalRepositoryClient.
     *
     * If no transaction isolation level is provided, the server will use its
     * default isolation level.
     * @param [isolationLevel] - an optional parameter to specify the
     * transaction's level of isolation; for possible values see
     * {@link TransactionIsolationLevel}
     * @returns transactional client
     */
    beginTransaction(isolationLevel?: string): Promise<TransactionalRepositoryClient>;
    getServiceName(): void;
}

/**
 * Service for uploading data streams.
 */
declare class UploadService {
    /**
     * Executes a POST request against the <code>/statements</code> endpoint. The
     * statements which have to be added are provided through a readable stream.
     * This method is useful for library client who wants to upload a big data set
     * into the repository.
     * @param contentType - is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param [context] - optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - optional uri against which any relative URIs
     * found in the data would be resolved.
     * @returns a service request that will be resolved when the
     * stream has been successfully consumed by the server
     */
    upload(readStream: ReadableStream, contentType: string, context?: NamedNode | string, baseURI?: string): ServiceRequest;
    /**
     * Executes a PUT request against the <code>/statements</code> endpoint. The
     * statements which have to be updated are provided through a readable stream.
     * This method is useful for overriding large set of statements that might be
     * provided as a readable stream e.g. reading from file.
     * @param context - restrict the operation. Will be encoded
     * as N-Triple if it is not already one
     * @param [baseURI] - optional uri against which any relative URIs
     * found in the data would be resolved.
     * @returns a service request that will be resolved when the
     * stream has been successfully consumed by the server
     */
    overwrite(readStream: ReadableStream, contentType: string, context: NamedNode | string, baseURI?: string): ServiceRequest;
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     * @param filePath - path to a file to be streamed to the server
     * @param contentType - MIME type of the file's content
     * @param [context] - restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns a service request that will be resolved when the
     * file has been successfully consumed by the server
     */
    addFile(filePath: string, contentType: string, context?: string | string[], baseURI?: string): ServiceRequest;
    /**
     * Uploads the file specified by the provided file path to the server
     * overwriting any data in the server's repository.
     *
     * The overwrite will be restricted if the context parameter is specified.
     *
     * See {@link #overwrite}
     * @param filePath - path to a file to be streamed to the server
     * @param contentType - MIME type of the file's content
     * @param [context] - restricts the operation to the given context.
     * Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns a service request that will be resolved when the
     * file has been successfully consumed by the server
     */
    putFile(filePath: string, contentType: string, context?: string, baseURI?: string): ServiceRequest;
    getServiceName(): void;
}

/**
 * Supported transaction levels.
 */
declare const enum TransactionIsolationLevel {
    NONE = "NONE",
    READ_UNCOMMITTED = "READ_UNCOMMITTED",
    READ_COMMITTED = "READ_COMMITTED",
    SNAPSHOT_READ = "SNAPSHOT_READ",
    SNAPSHOT = "SNAPSHOT",
    SERIALIZABLE = "SERIALIZABLE"
}

/**
 * Transactional RDF repository client implementation realizing transaction
 * specific operations.
 *
 * This client won't perform retries to multiple server endpoints due to when a
 * transaction is started all operations must be performed to the server where
 * it was started.
 *
 * The transaction is active until {@link #commit} or {@link #rollback} is
 * invoked. After that each sequential request will result in an error.
 */
declare class TransactionalRepositoryClient {
    constructor(repositoryClientConfig: RepositoryClientConfig);
    getLogger(): void;
    /**
     * Instantiates dependent services.
     */
    initServices(): void;
    execute(): void;
    /**
     * Updates the http request builder in the provided service request for
     * executing requests in a transaction.
     * @param serviceRequest - the request to mutate
     * @param action - the transaction action
     */
    decorateServiceRequest(serviceRequest: ServiceRequest, action: string): void;
    /**
     * Retrieves the size of the repository during the transaction and its
     * isolation level.
     *
     * Repository size is the amount of statements present.
     * @param [context] - if provided, the size calculation will
     * be restricted. Will be encoded as N-Triple if it is not already one
     * @returns a promise resolving to the size of the repo
     */
    getSize(context?: string | string[]): Promise<number>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The fetched data depends on the transaction isolation level.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     * @param payload - is an object holding the request
     * parameters.
     * @returns resolves with plain string or Quad according
     *      to provided response type.
     */
    get(payload: GetStatementsPayload): Promise<string | Quad>;
    /**
     * Executes request to query a repository.
     * @param payload - is an object holding request parameters
     * @returns the client can subscribe to the stream events and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     */
    query(payload: GetQueryPayload): Promise;
    /**
     * Executes a request with a SPARQL query to update repository data.
     * @param payload - request object containing the query
     * @returns promise that will be resolved if the update is
     * successful or rejected in case of failure
     */
    update(payload: UpdateQueryPayload): Promise<void>;
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     * @param payload - holding request parameters
     * @returns promise that will be resolved if the addition is
     * successful or rejected in case of failure
     */
    add(payload: AddStatementPayload): Promise<void>;
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     * @param quads - collection of quads to be sent as Turtle text
     * @param [context] - restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns promise that will be resolved if the addition
     * is successful or rejected in case of failure
     */
    addQuads(quads: Quad[], context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Deletes the statements in the provided Turtle or Trig formatted data.
     * @param data - payload data in Turtle or Trig format
     * @returns promise resolving after the data has been deleted
     * successfully
     */
    deleteData(data: string): Promise<void>;
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     * @param payload - is an object holding request params
     * @returns the client can subscribe to the readable
     * stream events and consume the emitted strings depending on the provided
     * response type as soon as they are available.
     */
    download(payload: GetStatementsPayload): Promise<WritableStream>;
    /**
     * Streams data to the repository from the provided readable stream.
     *
     * This method is useful for library client who wants to upload a big data set
     * into the repository during a transaction
     * @param readStream - stream with the data to be uploaded
     * @param contentType - is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param [context] - optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - optional uri against which any relative URIs
     * found in the data would be resolved.
     * @returns a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */
    upload(readStream: ReadableStream, contentType: string, context?: NamedNode | string, baseURI?: string): Promise<void>;
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     * @param filePath - path to a file to be streamed to the server
     * @param contentType - MIME type of the file's content
     * @param [context] - restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param [baseURI] - used to resolve relative URIs in the data
     * @returns a promise that will be resolved when the file has
     * been successfully consumed by the server
     */
    addFile(filePath: string, contentType: string, context?: string | string[], baseURI?: string): Promise<void>;
    /**
     * Commits the current transaction by applying any changes that have been
     * sent to the server.
     *
     * This effectively makes the transaction inactive.
     * @returns that will be resolved after successful commit
     */
    commit(): Promise<void>;
    /**
     * Rollbacks the current transaction reverting any changes in the server.
     *
     * This effectively makes the transaction inactive.
     * @returns that will be resolved after successful rollback
     */
    rollback(): Promise<void>;
    /**
     * @returns <code>true</code> if the transaction is active or
     * <code>false</code> otherwise
     */
    isActive(): boolean;
}

/**
 * Common utility functions.
 */
declare class CommonUtils {
    /**
     * Checks if at least one of the supplied arguments is undefined or null.
     * @returns <code>true</code> if there is null argument or
     *         <code>false</code> otherwise
     */
    static hasNullArguments(): boolean;
}

/**
 * Utilities related to working with files and the file system.
 */
declare class FileUtils {
    /**
     * Opens a readable stream from a file located at the provided file path.
     *
     * If the file path is blank or points to non existent file, the method will
     * result in an error.
     * @param filePath - path to the file to be read
     * @returns stream with the file data
     */
    static getReadStream(filePath: string): ReadableStream;
}

/**
 * Constructs new iterable for the provided collection.
 * @param iterable - the collection to iterate
 */
declare class Iterable {
    constructor(iterable: object[]);
    /**
     * Returns if there are elements left to be iterated from the collection.
     *
     * Use this method before calling {@link next()} to avoid out of bounds error.
     * @returns <code>true</code> if there is at least single element
     *                    left to iterate or <code>false</code> otherwise
     */
    hasNext(): boolean;
    /**
     * Returns the next object from the iterable collection.
     *
     * Before invoking this method, check if there are elements to iterate by
     * using {@link hasNext()} because if there are no objects left to iterate,
     * the function will blow with an error.
     * @returns the next iterated object from the collection
     */
    next(): any;
    /**
     * Resets the iterable to begin from the start as if it was just constructed.
     * @returns the current iterable for method chaining.
     */
    reset(): Iterable;
}

/**
 * Class with utility methods related to strings.
 */
declare class StringUtils {
    /**
     * Tells if the provided string is null or blank ignoring
     * whitespace characters.
     * @param string - the string to check
     * @returns <code>true</code> if the string is blank or
     *                    <code>false</code> otherwise
     */
    static isBlank(string: string): boolean;
    /**
     * Tells if the provided string is NOT null and NOT blank ignoring
     * whitespace characters.
     * @param string - the string to check
     * @returns <code>true</code> if the string is not blank or
     *                    <code>false</code> otherwise
     */
    static isNotBlank(string: string): boolean;
}

