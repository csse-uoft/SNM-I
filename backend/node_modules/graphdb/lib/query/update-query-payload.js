"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var QueryPayload = require('../query/query-payload');

var QueryContentType = require('../http/query-content-type');

var UPDATE_QUERY_OPERATION_TYPES = [QueryContentType.X_WWW_FORM_URLENCODED, QueryContentType.SPARQL_UPDATE];
/**
 * Payload object holding common request parameters applicable for the
 * statements endpoint with a sparql update query.
 *
 * The query is mandatory parameter.
 *
 * Content type parameter which is used for setting the Content-Type http header
 * is optional and by default
 * <code>application/sparql-update</code> type is set.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */

var UpdateQueryPayload = /*#__PURE__*/function (_QueryPayload) {
  _inherits(UpdateQueryPayload, _QueryPayload);

  var _super = _createSuper(UpdateQueryPayload);

  /**
   * Constructs this payload class.
   */
  function UpdateQueryPayload() {
    var _this;

    _classCallCheck(this, UpdateQueryPayload);

    _this = _super.call(this);
    _this.contentType = QueryContentType.SPARQL_UPDATE;
    return _this;
  }
  /**
   * @param {string} query The query as string to be evaluated.
   * @return {UpdateQueryPayload}
   */


  _createClass(UpdateQueryPayload, [{
    key: "setQuery",
    value: function setQuery(query) {
      if (typeof query !== 'string') {
        throw new Error('Query must be a string!');
      }

      this.payload.update = query;
      return this;
    }
    /**
     * @return {string} a query which was populated in the payload.
     */

  }, {
    key: "getQuery",
    value: function getQuery() {
      return this.payload.update;
    }
    /**
     * One or more named graph URIs to be used as default graph(s) for retrieving.
     * @param {(string|string[])} [defaultGraphs]
     * @return {UpdateQueryPayload}
     */

  }, {
    key: "setDefaultGraphs",
    value: function setDefaultGraphs(defaultGraphs) {
      this.payload['using-graph-uri'] = defaultGraphs;
      return this;
    }
    /**
     * @return {(string|string[])} Default graphs for the query for retrieving.
     */

  }, {
    key: "getDefaultGraphs",
    value: function getDefaultGraphs() {
      return this.payload['using-graph-uri'];
    }
    /**
     * One or more named graph URIs to be used as named graph(s) for retrieving.
     * @param {(string|string[])} [namedGraphs]
     * @return {UpdateQueryPayload}
     */

  }, {
    key: "setNamedGraphs",
    value: function setNamedGraphs(namedGraphs) {
      this.payload['using-named-graph-uri'] = namedGraphs;
      return this;
    }
    /**
     * @return {(string|string[])} Named graphs set for the query for retrieving.
     */

  }, {
    key: "getNamedGraphs",
    value: function getNamedGraphs() {
      return this.payload['using-named-graph-uri'];
    }
    /**
     * One or more default graphs for removing statements.
     * @param {(string|string[])} [removeGraphs]
     * @return {UpdateQueryPayload}
     */

  }, {
    key: "setRemoveGraphs",
    value: function setRemoveGraphs(removeGraphs) {
      this.payload['remove-graph-uri'] = removeGraphs;
      return this;
    }
    /**
     * @return {(string|string[])} Default graphs set for the query for removing.
     */

  }, {
    key: "getRemoveGraphs",
    value: function getRemoveGraphs() {
      return this.payload['remove-graph-uri'];
    }
    /**
     * One or more default graphs for inserting statements.
     * @param {(string|string[])} [insertGraphs]
     * @return {UpdateQueryPayload}
     */

  }, {
    key: "setInsertGraphs",
    value: function setInsertGraphs(insertGraphs) {
      this.payload['insert-graph-uri'] = insertGraphs;
      return this;
    }
    /**
     * @return {(string|string[])} Default graphs set for the query for inserting.
     */

  }, {
    key: "getInsertGraphs",
    value: function getInsertGraphs() {
      return this.payload['insert-graph-uri'];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "validateParams",
    value: function validateParams() {
      if (!this.payload.update) {
        throw new Error('Parameter query is mandatory!');
      }

      return true;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "getSupportedContentTypes",
    value: function getSupportedContentTypes() {
      return UPDATE_QUERY_OPERATION_TYPES;
    }
  }]);

  return UpdateQueryPayload;
}(QueryPayload);

module.exports = UpdateQueryPayload;