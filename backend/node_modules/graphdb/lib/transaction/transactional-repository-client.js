"use strict";

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _get(target, property, receiver) { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var BaseRepositoryClient = require('../repository/base-repository-client');

var HttpRequestBuilder = require('../http/http-request-builder');

var RepositoryService = require('../service/repository-service');

var StatementsService = require('../service/statements-service');

var QueryService = require('../service/query-service');

var UploadService = require('../service/upload-service');

var DownloadService = require('../service/download-service');

var ConsoleLogger = require('../logging/console-logger');

var RDFMimeType = require('../http/rdf-mime-type');

var StringUtils = require('../util/string-utils');
/**
 * Transactional RDF repository client implementation realizing transaction
 * specific operations.
 *
 * This client won't perform retries to multiple server endpoints due to when a
 * transaction is started all operations must be performed to the server where
 * it was started.
 *
 * The transaction is active until {@link #commit} or {@link #rollback} is
 * invoked. After that each sequential request will result in an error.
 *
 * @class
 * @author Mihail Radkov
 * @author Svilen Velikov
 */


var TransactionalRepositoryClient = /*#__PURE__*/function (_BaseRepositoryClient) {
  _inherits(TransactionalRepositoryClient, _BaseRepositoryClient);

  var _super = _createSuper(TransactionalRepositoryClient);

  /**
   * @param {RepositoryClientConfig} repositoryClientConfig
   */
  function TransactionalRepositoryClient(repositoryClientConfig) {
    var _this;

    _classCallCheck(this, TransactionalRepositoryClient);

    _this = _super.call(this, repositoryClientConfig);

    _this.initServices();

    _this.active = true;
    return _this;
  }
  /**
   * @inheritDoc
   */


  _createClass(TransactionalRepositoryClient, [{
    key: "getLogger",
    value: function getLogger() {
      return new ConsoleLogger({
        name: 'TransactionalRepositoryClient'
      });
    }
    /**
     * Instantiates dependent services.
     */

  }, {
    key: "initServices",
    value: function initServices() {
      var httpRequestExecutor = this.execute.bind(this);
      var parseExecutor = this.parse.bind(this);
      this.repositoryService = new RepositoryService(httpRequestExecutor);
      this.statementsService = new StatementsService(httpRequestExecutor, this.parserRegistry, parseExecutor);
      this.queryService = new QueryService(httpRequestExecutor, parseExecutor);
      this.uploadService = new UploadService(httpRequestExecutor);
      this.downloadService = new DownloadService(httpRequestExecutor);
    }
    /**
     * @inheritDoc
     * @override
     * @throws {Error} if the transaction has been committed or rollbacked
     */

  }, {
    key: "execute",
    value: function execute(requestBuilder) {
      if (!this.active) {
        throw new Error('Transaction is inactive');
      }

      return _get(_getPrototypeOf(TransactionalRepositoryClient.prototype), "execute", this).call(this, requestBuilder);
    }
    /**
     * Updates the http request builder in the provided service request for
     * executing requests in a transaction.
     *
     * @param {ServiceRequest} serviceRequest the request to mutate
     * @param {string} action the transaction action
     */

  }, {
    key: "decorateServiceRequest",
    value: function decorateServiceRequest(serviceRequest, action) {
      var requestBuilder = serviceRequest.getHttpRequestBuilder();
      requestBuilder.setMethod('put').setUrl('').addParam('action', action);
    }
    /**
     * Retrieves the size of the repository during the transaction and its
     * isolation level.
     *
     * Repository size is the amount of statements present.
     *
     * @param {string|string[]} [context] if provided, the size calculation will
     * be restricted. Will be encoded as N-Triple if it is not already one
     * @return {Promise<number>} a promise resolving to the size of the repo
     */

  }, {
    key: "getSize",
    value: function getSize(context) {
      var serviceRequest = this.repositoryService.getSize(context);
      this.decorateServiceRequest(serviceRequest, 'SIZE');
      return serviceRequest.execute();
    }
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The fetched data depends on the transaction isolation level.
     *
     * Provided values will be automatically converted to N-Triples if they are
     * not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding the request
     * parameters.
     * @return {Promise<string|Quad>} resolves with plain string or Quad according
     *      to provided response type.
     */

  }, {
    key: "get",
    value: function get(payload) {
      var serviceRequest = this.statementsService.get(payload);
      this.decorateServiceRequest(serviceRequest, 'GET');
      return serviceRequest.execute();
    }
    /**
     * Executes request to query a repository.
     *
     * @param {GetQueryPayload} payload is an object holding request parameters
     *
     * @return {Promise} the client can subscribe to the stream events and consume
     * the emitted strings or Quads depending on the provided response type as
     * soon as they are available.
     * @throws {Error} if the payload is misconfigured
     */

  }, {
    key: "query",
    value: function query(payload) {
      var serviceRequest = this.queryService.query(payload);
      this.decorateServiceRequest(serviceRequest, 'QUERY');
      return serviceRequest.execute();
    }
    /**
     * Executes a request with a SPARQL query to update repository data.
     *
     * @param {UpdateQueryPayload} payload request object containing the query
     * @return {Promise<void>} promise that will be resolved if the update is
     * successful or rejected in case of failure
     * @throws {Error} if the payload is misconfigured
     */

  }, {
    key: "update",
    value: function update(payload) {
      var serviceRequest = this.queryService.update(payload);
      this.decorateServiceRequest(serviceRequest, 'UPDATE');
      return serviceRequest.execute();
    }
    /**
     * Saves the provided statement payload in the repository.
     *
     * The payload will be converted to a quad or a collection of quads in case
     * there are multiple contexts.
     *
     * After the conversion, the produced quad(s) will be serialized to Turtle or
     * Trig format and send to the repository as payload.
     *
     * See {@link #addQuads()}.
     *
     * @param {AddStatementPayload} payload holding request parameters
     *
     * @return {Promise<void>} promise that will be resolved if the addition is
     * successful or rejected in case of failure
     * @throws {Error} if the payload is not provided or the payload has null
     * subject, predicate and/or object
     */

  }, {
    key: "add",
    value: function add(payload) {
      var serviceRequest = this.statementsService.add(payload);
      this.decorateServiceRequest(serviceRequest, 'ADD');
      return serviceRequest.execute();
    }
    /**
     * Serializes the provided quads to Turtle format and sends them to the
     * repository as payload.
     *
     * If any of the quads have a graph, then the text will be serialized to the
     * Trig format which is an extended version of Turtle supporting contexts.
     *
     * @param {Quad[]} quads collection of quads to be sent as Turtle text
     * @param {string|string[]} [context] restricts the insertion to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     * @return {Promise<void>} promise that will be resolved if the addition
     * is successful or rejected in case of failure
     */

  }, {
    key: "addQuads",
    value: function addQuads(quads, context, baseURI) {
      var serviceRequest = this.statementsService.addQuads(quads, context, baseURI);
      this.decorateServiceRequest(serviceRequest, 'ADD');
      return serviceRequest.execute();
    }
    /**
     * Deletes the statements in the provided Turtle or Trig formatted data.
     *
     * @param {string} data payload data in Turtle or Trig format
     * @return {Promise<void>} promise resolving after the data has been deleted
     * successfully
     * @throws {Error} if no data is provided for deleting
     */

  }, {
    key: "deleteData",
    value: function deleteData(data) {
      var _this2 = this;

      if (StringUtils.isBlank(data)) {
        throw new Error('Turtle data is required when deleting statements');
      }

      var requestBuilder = HttpRequestBuilder.httpPut('').setData(data).setParams({
        action: 'DELETE'
      }).addContentTypeHeader(RDFMimeType.TRIG);
      return this.execute(requestBuilder).then(function (response) {
        _this2.logger.debug(_this2.getLogPayload(response, {
          data: data
        }), 'Deleted data');
      });
    }
    /**
     * Fetch rdf data from statements endpoint using provided parameters.
     *
     * The request is configured so that expected response should be a readable
     * stream.
     *
     * Provided request params will be automatically converted to N-Triples if
     * they are not already encoded as such.
     *
     * @param {GetStatementsPayload} payload is an object holding request params
     *
     * @return {Promise<WritableStream>} the client can subscribe to the readable
     * stream events and consume the emitted strings depending on the provided
     * response type as soon as they are available.
     */

  }, {
    key: "download",
    value: function download(payload) {
      var serviceRequest = this.downloadService.download(payload);
      this.decorateServiceRequest(serviceRequest, 'GET');
      return serviceRequest.execute();
    }
    /**
     * Streams data to the repository from the provided readable stream.
     *
     * This method is useful for library client who wants to upload a big data set
     * into the repository during a transaction
     *
     * @param {ReadableStream} readStream stream with the data to be uploaded
     * @param {string} contentType is one of RDF mime type formats,
     *                application/x-rdftransaction' for a transaction document or
     *                application/x-www-form-urlencoded
     * @param {NamedNode|string} [context] optional context to restrict the
     * operation. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] optional uri against which any relative URIs
     * found in the data would be resolved.
     *
     * @return {Promise<void>} a promise that will be resolved when the stream has
     * been successfully consumed by the server
     */

  }, {
    key: "upload",
    value: function upload(readStream, contentType, context, baseURI) {
      var serviceRequest = this.uploadService.upload(readStream, contentType, context, baseURI);
      this.decorateServiceRequest(serviceRequest, 'ADD');
      return serviceRequest.execute();
    }
    /**
     * Uploads the file specified by the provided file path to the server.
     *
     * See {@link #upload}
     *
     * @param {string} filePath path to a file to be streamed to the server
     * @param {string} contentType MIME type of the file's content
     * @param {string|string[]} [context] restricts the operation to the given
     * context. Will be encoded as N-Triple if it is not already one
     * @param {string} [baseURI] used to resolve relative URIs in the data
     *
     * @return {Promise<void>} a promise that will be resolved when the file has
     * been successfully consumed by the server
     */

  }, {
    key: "addFile",
    value: function addFile(filePath, contentType, context, baseURI) {
      var serviceRequest = this.uploadService.addFile(filePath, contentType, context, baseURI);
      this.decorateServiceRequest(serviceRequest, 'ADD');
      return serviceRequest.execute();
    }
    /**
     * Commits the current transaction by applying any changes that have been
     * sent to the server.
     *
     * This effectively makes the transaction inactive.
     *
     * @return {Promise<void>} that will be resolved after successful commit
     */

  }, {
    key: "commit",
    value: function commit() {
      var _this3 = this;

      var requestBuilder = HttpRequestBuilder.httpPut('').setParams({
        action: 'COMMIT'
      });
      return this.execute(requestBuilder).then(function (response) {
        _this3.active = false;

        _this3.logger.debug(_this3.getLogPayload(response), 'Transaction commit');
      })["catch"](function (err) {
        _this3.active = false;
        return Promise.reject(err);
      });
    }
    /**
     * Rollbacks the current transaction reverting any changes in the server.
     *
     * This effectively makes the transaction inactive.
     *
     * @return {Promise<void>} that will be resolved after successful rollback
     */

  }, {
    key: "rollback",
    value: function rollback() {
      var _this4 = this;

      var requestBuilder = HttpRequestBuilder.httpDelete('');
      return this.execute(requestBuilder).then(function (response) {
        _this4.active = false;

        _this4.logger.debug(_this4.getLogPayload(response), 'Transaction rollback');
      })["catch"](function (err) {
        _this4.active = false;
        return Promise.reject(err);
      });
    }
    /**
     * @return {boolean} <code>true</code> if the transaction is active or
     * <code>false</code> otherwise
     */

  }, {
    key: "isActive",
    value: function isActive() {
      return this.active;
    }
  }]);

  return TransactionalRepositoryClient;
}(BaseRepositoryClient);

module.exports = TransactionalRepositoryClient;